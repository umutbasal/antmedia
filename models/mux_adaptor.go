// Code generated by go-swagger;

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// MuxAdaptor mux adaptor
//
// swagger:model MuxAdaptor
type MuxAdaptor struct {

	// absolute time ms
	AbsoluteTimeMs int64 `json:"absoluteTimeMs,omitempty"`

	// app settings
	AppSettings *AppSettings `json:"appSettings,omitempty"`

	// appending
	Appending bool `json:"appending,omitempty"`

	// audio codec parameters
	AudioCodecParameters *AVCodecParameters `json:"audioCodecParameters,omitempty"`

	// audio stream index
	AudioStreamIndex int32 `json:"audioStreamIndex,omitempty"`

	// audio time base
	AudioTimeBase *AVRational `json:"audioTimeBase,omitempty"`

	// avc
	Avc bool `json:"avc,omitempty"`

	// broadcast
	Broadcast *Broadcast `json:"broadcast,omitempty"`

	// broadcast stream
	BroadcastStream *ClientBroadcastStream `json:"broadcastStream,omitempty"`

	// buffer queue
	BufferQueue []*IStreamPacket `json:"bufferQueue"`

	// buffer time ms
	BufferTimeMs int64 `json:"bufferTimeMs,omitempty"`

	// buffering
	Buffering bool `json:"buffering,omitempty"`

	// dash muxer
	DashMuxer *Muxer `json:"dashMuxer,omitempty"`

	// data channel web hook URL
	DataChannelWebHookURL string `json:"dataChannelWebHookURL,omitempty"`

	// data store
	DataStore *DataStore `json:"dataStore,omitempty"`

	// delete d a s h files on exit
	DeleteDASHFilesOnExit bool `json:"deleteDASHFilesOnExit,omitempty"`

	// enable audio
	EnableAudio bool `json:"enableAudio,omitempty"`

	// enable video
	EnableVideo bool `json:"enableVideo,omitempty"`

	// encoder settings list
	EncoderSettingsList []*EncoderSettings `json:"encoderSettingsList"`

	// endpoint status update map
	EndpointStatusUpdateMap map[string]string `json:"endpointStatusUpdateMap,omitempty"`

	// file consumer
	FileConsumer *FileConsumer `json:"fileConsumer,omitempty"`

	// file name
	FileName string `json:"fileName,omitempty"`

	// input queue size
	InputQueueSize int32 `json:"inputQueueSize,omitempty"`

	// is health check started map
	IsHealthCheckStartedMap map[string]bool `json:"isHealthCheckStartedMap,omitempty"`

	// last frame timestamp
	LastFrameTimestamp int32 `json:"lastFrameTimestamp,omitempty"`

	// muxer list
	MuxerList []*Muxer `json:"muxerList"`

	// object detection enabled
	ObjectDetectionEnabled bool `json:"objectDetectionEnabled,omitempty"`

	// packet time list
	PacketTimeList []*PacketTime `json:"packetTimeList"`

	// preview create period
	PreviewCreatePeriod int32 `json:"previewCreatePeriod,omitempty"`

	// preview height
	PreviewHeight int32 `json:"previewHeight,omitempty"`

	// preview overwrite
	PreviewOverwrite bool `json:"previewOverwrite,omitempty"`

	// recording
	Recording bool `json:"recording,omitempty"`

	// start time
	StartTime int64 `json:"startTime,omitempty"`

	// stop request exist
	StopRequestExist bool `json:"stopRequestExist,omitempty"`

	// storage client
	StorageClient *StorageClient `json:"storageClient,omitempty"`

	// stream handler
	StreamHandler *IAntMediaStreamHandler `json:"streamHandler,omitempty"`

	// stream Id
	StreamID string `json:"streamId,omitempty"`

	// stream source
	StreamSource bool `json:"streamSource,omitempty"`

	// vertx
	Vertx *Vertx `json:"vertx,omitempty"`

	// video codec parameters
	VideoCodecParameters *AVCodecParameters `json:"videoCodecParameters,omitempty"`

	// video stream index
	VideoStreamIndex int32 `json:"videoStreamIndex,omitempty"`

	// video time base
	VideoTimeBase *AVRational `json:"videoTimeBase,omitempty"`

	// web r t c enabled
	WebRTCEnabled bool `json:"webRTCEnabled,omitempty"`
}

// Validate validates this mux adaptor
func (m *MuxAdaptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAppSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAudioCodecParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAudioTimeBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBroadcast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBroadcastStream(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBufferQueue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDashMuxer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataStore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncoderSettingsList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileConsumer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMuxerList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePacketTimeList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageClient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreamHandler(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVertx(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVideoCodecParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVideoTimeBase(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MuxAdaptor) validateAppSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.AppSettings) { // not required
		return nil
	}

	if m.AppSettings != nil {
		if err := m.AppSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appSettings")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateAudioCodecParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.AudioCodecParameters) { // not required
		return nil
	}

	if m.AudioCodecParameters != nil {
		if err := m.AudioCodecParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("audioCodecParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("audioCodecParameters")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateAudioTimeBase(formats strfmt.Registry) error {
	if swag.IsZero(m.AudioTimeBase) { // not required
		return nil
	}

	if m.AudioTimeBase != nil {
		if err := m.AudioTimeBase.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("audioTimeBase")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("audioTimeBase")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateBroadcast(formats strfmt.Registry) error {
	if swag.IsZero(m.Broadcast) { // not required
		return nil
	}

	if m.Broadcast != nil {
		if err := m.Broadcast.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("broadcast")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateBroadcastStream(formats strfmt.Registry) error {
	if swag.IsZero(m.BroadcastStream) { // not required
		return nil
	}

	if m.BroadcastStream != nil {
		if err := m.BroadcastStream.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcastStream")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("broadcastStream")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateBufferQueue(formats strfmt.Registry) error {
	if swag.IsZero(m.BufferQueue) { // not required
		return nil
	}

	for i := 0; i < len(m.BufferQueue); i++ {
		if swag.IsZero(m.BufferQueue[i]) { // not required
			continue
		}

		if m.BufferQueue[i] != nil {
			if err := m.BufferQueue[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bufferQueue" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bufferQueue" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) validateDashMuxer(formats strfmt.Registry) error {
	if swag.IsZero(m.DashMuxer) { // not required
		return nil
	}

	if m.DashMuxer != nil {
		if err := m.DashMuxer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dashMuxer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dashMuxer")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateDataStore(formats strfmt.Registry) error {
	if swag.IsZero(m.DataStore) { // not required
		return nil
	}

	if m.DataStore != nil {
		if err := m.DataStore.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataStore")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataStore")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateEncoderSettingsList(formats strfmt.Registry) error {
	if swag.IsZero(m.EncoderSettingsList) { // not required
		return nil
	}

	for i := 0; i < len(m.EncoderSettingsList); i++ {
		if swag.IsZero(m.EncoderSettingsList[i]) { // not required
			continue
		}

		if m.EncoderSettingsList[i] != nil {
			if err := m.EncoderSettingsList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("encoderSettingsList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("encoderSettingsList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) validateFileConsumer(formats strfmt.Registry) error {
	if swag.IsZero(m.FileConsumer) { // not required
		return nil
	}

	if m.FileConsumer != nil {
		if err := m.FileConsumer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileConsumer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileConsumer")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateMuxerList(formats strfmt.Registry) error {
	if swag.IsZero(m.MuxerList) { // not required
		return nil
	}

	for i := 0; i < len(m.MuxerList); i++ {
		if swag.IsZero(m.MuxerList[i]) { // not required
			continue
		}

		if m.MuxerList[i] != nil {
			if err := m.MuxerList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("muxerList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("muxerList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) validatePacketTimeList(formats strfmt.Registry) error {
	if swag.IsZero(m.PacketTimeList) { // not required
		return nil
	}

	for i := 0; i < len(m.PacketTimeList); i++ {
		if swag.IsZero(m.PacketTimeList[i]) { // not required
			continue
		}

		if m.PacketTimeList[i] != nil {
			if err := m.PacketTimeList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("packetTimeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("packetTimeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) validateStorageClient(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageClient) { // not required
		return nil
	}

	if m.StorageClient != nil {
		if err := m.StorageClient.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storageClient")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storageClient")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateStreamHandler(formats strfmt.Registry) error {
	if swag.IsZero(m.StreamHandler) { // not required
		return nil
	}

	if m.StreamHandler != nil {
		if err := m.StreamHandler.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("streamHandler")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("streamHandler")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateVertx(formats strfmt.Registry) error {
	if swag.IsZero(m.Vertx) { // not required
		return nil
	}

	if m.Vertx != nil {
		if err := m.Vertx.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vertx")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vertx")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateVideoCodecParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.VideoCodecParameters) { // not required
		return nil
	}

	if m.VideoCodecParameters != nil {
		if err := m.VideoCodecParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("videoCodecParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("videoCodecParameters")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) validateVideoTimeBase(formats strfmt.Registry) error {
	if swag.IsZero(m.VideoTimeBase) { // not required
		return nil
	}

	if m.VideoTimeBase != nil {
		if err := m.VideoTimeBase.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("videoTimeBase")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("videoTimeBase")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mux adaptor based on the context it is used
func (m *MuxAdaptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAppSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAudioCodecParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAudioTimeBase(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBroadcast(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBroadcastStream(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBufferQueue(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDashMuxer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataStore(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEncoderSettingsList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileConsumer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMuxerList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePacketTimeList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageClient(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStreamHandler(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVertx(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVideoCodecParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVideoTimeBase(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MuxAdaptor) contextValidateAppSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.AppSettings != nil {
		if err := m.AppSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appSettings")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateAudioCodecParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.AudioCodecParameters != nil {
		if err := m.AudioCodecParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("audioCodecParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("audioCodecParameters")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateAudioTimeBase(ctx context.Context, formats strfmt.Registry) error {

	if m.AudioTimeBase != nil {
		if err := m.AudioTimeBase.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("audioTimeBase")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("audioTimeBase")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateBroadcast(ctx context.Context, formats strfmt.Registry) error {

	if m.Broadcast != nil {
		if err := m.Broadcast.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("broadcast")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateBroadcastStream(ctx context.Context, formats strfmt.Registry) error {

	if m.BroadcastStream != nil {
		if err := m.BroadcastStream.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcastStream")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("broadcastStream")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateBufferQueue(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BufferQueue); i++ {

		if m.BufferQueue[i] != nil {
			if err := m.BufferQueue[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bufferQueue" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bufferQueue" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) contextValidateDashMuxer(ctx context.Context, formats strfmt.Registry) error {

	if m.DashMuxer != nil {
		if err := m.DashMuxer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dashMuxer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dashMuxer")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateDataStore(ctx context.Context, formats strfmt.Registry) error {

	if m.DataStore != nil {
		if err := m.DataStore.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataStore")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataStore")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateEncoderSettingsList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.EncoderSettingsList); i++ {

		if m.EncoderSettingsList[i] != nil {
			if err := m.EncoderSettingsList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("encoderSettingsList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("encoderSettingsList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) contextValidateFileConsumer(ctx context.Context, formats strfmt.Registry) error {

	if m.FileConsumer != nil {
		if err := m.FileConsumer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileConsumer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileConsumer")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateMuxerList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MuxerList); i++ {

		if m.MuxerList[i] != nil {
			if err := m.MuxerList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("muxerList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("muxerList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) contextValidatePacketTimeList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PacketTimeList); i++ {

		if m.PacketTimeList[i] != nil {
			if err := m.PacketTimeList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("packetTimeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("packetTimeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MuxAdaptor) contextValidateStorageClient(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageClient != nil {
		if err := m.StorageClient.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storageClient")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storageClient")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateStreamHandler(ctx context.Context, formats strfmt.Registry) error {

	if m.StreamHandler != nil {
		if err := m.StreamHandler.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("streamHandler")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("streamHandler")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateVertx(ctx context.Context, formats strfmt.Registry) error {

	if m.Vertx != nil {
		if err := m.Vertx.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vertx")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vertx")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateVideoCodecParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.VideoCodecParameters != nil {
		if err := m.VideoCodecParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("videoCodecParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("videoCodecParameters")
			}
			return err
		}
	}

	return nil
}

func (m *MuxAdaptor) contextValidateVideoTimeBase(ctx context.Context, formats strfmt.Registry) error {

	if m.VideoTimeBase != nil {
		if err := m.VideoTimeBase.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("videoTimeBase")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("videoTimeBase")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MuxAdaptor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MuxAdaptor) UnmarshalBinary(b []byte) error {
	var res MuxAdaptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
