// Code generated by go-swagger;

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// StreamFetcher stream fetcher
//
// swagger:model StreamFetcher
type StreamFetcher struct {

	// avpacket
	Avpacket *AVPacket `json:"avpacket,omitempty"`

	// buffer time
	BufferTime int32 `json:"bufferTime,omitempty"`

	// camera error
	CameraError *Result `json:"cameraError,omitempty"`

	// data store
	DataStore *DataStore `json:"dataStore,omitempty"`

	// exception in thread
	ExceptionInThread bool `json:"exceptionInThread,omitempty"`

	// instance
	Instance *AntMediaApplicationAdapter `json:"instance,omitempty"`

	// mux adaptor
	MuxAdaptor *MuxAdaptor `json:"muxAdaptor,omitempty"`

	// restart stream
	RestartStream bool `json:"restartStream,omitempty"`

	// scope
	Scope *IScope `json:"scope,omitempty"`

	// stop request received
	StopRequestReceived bool `json:"stopRequestReceived,omitempty"`

	// stopped
	Stopped bool `json:"stopped,omitempty"`

	// stream alive
	StreamAlive bool `json:"streamAlive,omitempty"`

	// stream fetcher listener
	StreamFetcherListener IStreamFetcherListener `json:"streamFetcherListener,omitempty"`

	// stream Id
	StreamID string `json:"streamId,omitempty"`

	// stream Url
	StreamURL string `json:"streamUrl,omitempty"`

	// thread
	Thread *WorkerThread `json:"thread,omitempty"`

	// thread active
	ThreadActive bool `json:"threadActive,omitempty"`
}

// Validate validates this stream fetcher
func (m *StreamFetcher) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvpacket(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCameraError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataStore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMuxAdaptor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThread(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StreamFetcher) validateAvpacket(formats strfmt.Registry) error {
	if swag.IsZero(m.Avpacket) { // not required
		return nil
	}

	if m.Avpacket != nil {
		if err := m.Avpacket.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("avpacket")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("avpacket")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) validateCameraError(formats strfmt.Registry) error {
	if swag.IsZero(m.CameraError) { // not required
		return nil
	}

	if m.CameraError != nil {
		if err := m.CameraError.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cameraError")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cameraError")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) validateDataStore(formats strfmt.Registry) error {
	if swag.IsZero(m.DataStore) { // not required
		return nil
	}

	if m.DataStore != nil {
		if err := m.DataStore.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataStore")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataStore")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) validateInstance(formats strfmt.Registry) error {
	if swag.IsZero(m.Instance) { // not required
		return nil
	}

	if m.Instance != nil {
		if err := m.Instance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instance")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) validateMuxAdaptor(formats strfmt.Registry) error {
	if swag.IsZero(m.MuxAdaptor) { // not required
		return nil
	}

	if m.MuxAdaptor != nil {
		if err := m.MuxAdaptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("muxAdaptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("muxAdaptor")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) validateThread(formats strfmt.Registry) error {
	if swag.IsZero(m.Thread) { // not required
		return nil
	}

	if m.Thread != nil {
		if err := m.Thread.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("thread")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("thread")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this stream fetcher based on the context it is used
func (m *StreamFetcher) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvpacket(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCameraError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataStore(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMuxAdaptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThread(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StreamFetcher) contextValidateAvpacket(ctx context.Context, formats strfmt.Registry) error {

	if m.Avpacket != nil {
		if err := m.Avpacket.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("avpacket")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("avpacket")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) contextValidateCameraError(ctx context.Context, formats strfmt.Registry) error {

	if m.CameraError != nil {
		if err := m.CameraError.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cameraError")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cameraError")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) contextValidateDataStore(ctx context.Context, formats strfmt.Registry) error {

	if m.DataStore != nil {
		if err := m.DataStore.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataStore")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataStore")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) contextValidateInstance(ctx context.Context, formats strfmt.Registry) error {

	if m.Instance != nil {
		if err := m.Instance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instance")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) contextValidateMuxAdaptor(ctx context.Context, formats strfmt.Registry) error {

	if m.MuxAdaptor != nil {
		if err := m.MuxAdaptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("muxAdaptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("muxAdaptor")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {
		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *StreamFetcher) contextValidateThread(ctx context.Context, formats strfmt.Registry) error {

	if m.Thread != nil {
		if err := m.Thread.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("thread")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("thread")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StreamFetcher) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StreamFetcher) UnmarshalBinary(b []byte) error {
	var res StreamFetcher
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
